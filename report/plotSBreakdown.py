#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Plot S Score Breakdown by Section
---------------------------------
This script reads the CSV generated by calculateProb.py and creates a stacked bar chart
showing the breakdown of S scores for each section, with each bar divided by the 
fraction of S_v, S_a, S_cp, S_sp, and S_temp components.

Usage:
    python plotSBreakdown.py --csv /path/to/bridge_risk.csv --output /path/to/output.png
"""

import argparse
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from typing import Optional

def plot_s_breakdown(csv_path: str, output_path: Optional[str] = None, 
                    figsize: tuple = (12, 8), dpi: int = 200):
    """
    Plot S score breakdown as stacked bars for each section.
    
    Args:
        csv_path: Path to the CSV file generated by calculateProb.py
        output_path: Optional output path for the plot (if None, displays plot)
        figsize: Figure size tuple (width, height)
        dpi: DPI for saved plot
    """
    # Read the CSV file
    df = pd.read_csv(csv_path)
    
    # Sort sections by numerical order (S1, S2, S3, etc.)
    df['Section_Num'] = df['Section'].str.extract('(\d+)').astype(int)
    df = df.sort_values('Section_Num').reset_index(drop=True)
    
    # Extract section names and S score components
    sections = df['Section'].tolist()
    s_v = df['S_v'].values
    s_a = df['S_a'].values
    s_cp = df['S_cp'].values
    s_sp = df['S_sp'].values
    s_temp = df['S_temp'].values
    s_total = df['S'].values
    
    # Calculate the weighted contributions (these are the actual fractions used in S calculation)
    # Based on calculateProb.py line 365: S = 0.40 * scores.S_v + 0.20 * scores.S_a + 0.20 * scores.S_cp + 0.10 * S_sp + 0.10 * scores.S_temp
    weights = np.array([0.40, 0.20, 0.20, 0.10, 0.10])
    
    # Calculate weighted contributions
    contrib_v = weights[0] * s_v
    contrib_a = weights[1] * s_a
    contrib_cp = weights[2] * s_cp
    contrib_sp = weights[3] * s_sp
    contrib_temp = weights[4] * s_temp
    
    # Create the stacked bar chart
    fig, ax = plt.subplots(figsize=figsize)
    
    # Set up the bar positions
    x_pos = np.arange(len(sections))
    width = 0.8
    
    # Create stacked bars
    bottom = np.zeros(len(sections))
    
    # Plot each component
    bars_v = ax.bar(x_pos, contrib_v, width, bottom=bottom, 
                   label=f'S_v (velocity) × {weights[0]}', 
                   color='#ff7f0e', alpha=0.8)
    bottom += contrib_v
    
    bars_a = ax.bar(x_pos, contrib_a, width, bottom=bottom, 
                   label=f'S_a (acceleration) × {weights[1]}', 
                   color='#2ca02c', alpha=0.8)
    bottom += contrib_a
    
    bars_cp = ax.bar(x_pos, contrib_cp, width, bottom=bottom, 
                    label=f'S_cp (change-point) × {weights[2]}', 
                    color='#d62728', alpha=0.8)
    bottom += contrib_cp
    
    bars_sp = ax.bar(x_pos, contrib_sp, width, bottom=bottom, 
                    label=f'S_sp (spatial) × {weights[3]}', 
                    color='#9467bd', alpha=0.8)
    bottom += contrib_sp
    
    bars_temp = ax.bar(x_pos, contrib_temp, width, bottom=bottom, 
                      label=f'S_temp (temperature) × {weights[4]}', 
                      color='#8c564b', alpha=0.8)
    
    # Add total S score as text on top of each bar
    for i, (x, total_s) in enumerate(zip(x_pos, s_total)):
        ax.text(x, total_s + 0.02, f'{total_s:.3f}', 
               ha='center', va='bottom', fontsize=7, fontweight='bold',
               bbox=dict(boxstyle='round,pad=0.2', facecolor='white', alpha=0.8, edgecolor='gray'))
    
    # Customize the plot
    ax.set_xlabel('Bridge Sections', fontsize=12, fontweight='bold')
    ax.set_ylabel('S Score Contribution', fontsize=12, fontweight='bold')
    ax.set_title('S Score Breakdown by Section\n(Stacked bars show weighted contributions)', 
                fontsize=14, fontweight='bold', pad=20)
    
    # Set x-axis labels
    ax.set_xticks(x_pos)
    ax.set_xticklabels(sections, rotation=45, ha='right')
    
    # Add legend
    ax.legend(bbox_to_anchor=(1.05, 1), loc='upper left', fontsize=10)
    
    # Add grid for better readability
    ax.grid(True, alpha=0.3, axis='y')
    ax.set_axisbelow(True)
    
    # Set y-axis limits
    ax.set_ylim(0, 1)
    
    # Add a horizontal line at S=1.0 for reference
    # ax.axhline(y=1.0, color='red', linestyle='--', alpha=0.7, linewidth=2)
    # ax.text(len(sections)-1, 1.05, 'S = 1.0', ha='right', va='bottom', 
    #        color='red', fontweight='bold', fontsize=10)
    
    # Adjust layout to prevent label cutoff
    plt.tight_layout()
    
    # Save or display the plot
    if output_path:
        plt.savefig(output_path, dpi=dpi, bbox_inches='tight')
        print(f"Plot saved to: {output_path}")
    else:
        plt.show()
    
    return fig, ax

def create_summary_table(csv_path: str, output_path: Optional[str] = None):
    """
    Create a summary table showing the breakdown of S scores.
    
    Args:
        csv_path: Path to the CSV file generated by calculateProb.py
        output_path: Optional output path for the summary table CSV
    """
    df = pd.read_csv(csv_path)
    
    # Sort sections by numerical order (S1, S2, S3, etc.)
    df['Section_Num'] = df['Section'].str.extract('(\d+)').astype(int)
    df = df.sort_values('Section_Num').reset_index(drop=True)
    
    # Calculate weighted contributions
    weights = np.array([0.30, 0.20, 0.25, 0.15, 0.10])
    
    contrib_v = weights[0] * df['S_v']
    contrib_a = weights[1] * df['S_a']
    contrib_cp = weights[2] * df['S_cp']
    contrib_sp = weights[3] * df['S_sp']
    contrib_temp = weights[4] * df['S_temp']
    
    # Create summary dataframe
    summary_df = pd.DataFrame({
        'Section': df['Section'],
        'S_Total': df['S'],
        'S_v_contrib': contrib_v,
        'S_a_contrib': contrib_a,
        'S_cp_contrib': contrib_cp,
        'S_sp_contrib': contrib_sp,
        'S_temp_contrib': contrib_temp,
        'S_v_raw': df['S_v'],
        'S_a_raw': df['S_a'],
        'S_cp_raw': df['S_cp'],
        'S_sp_raw': df['S_sp'],
        'S_temp_raw': df['S_temp'],
        'RiskClass': df['RiskClass']
    })
    
    # Round to 4 decimal places
    numeric_cols = summary_df.select_dtypes(include=[np.number]).columns
    summary_df[numeric_cols] = summary_df[numeric_cols].round(4)
    
    if output_path:
        summary_df.to_csv(output_path, index=False)
        print(f"Summary table saved to: {output_path}")
    
    return summary_df

def main():
    parser = argparse.ArgumentParser(description="Plot S score breakdown by section")
    parser.add_argument("--csv", required=True, help="Path to bridge risk CSV file")
    parser.add_argument("--output", help="Output path for the plot (PNG format)")
    parser.add_argument("--summary", help="Output path for summary table (CSV format)")
    parser.add_argument("--figsize", nargs=2, type=float, default=[12, 8], 
                       help="Figure size as width height (default: 12 8)")
    parser.add_argument("--dpi", type=int, default=200, help="DPI for saved plot (default: 200)")
    
    args = parser.parse_args()
    
    # Create the plot
    fig, ax = plot_s_breakdown(args.csv, args.output, tuple(args.figsize), args.dpi)
    
    # Create summary table if requested
    if args.summary:
        summary_df = create_summary_table(args.csv, args.summary)
        print("\nSummary of S score breakdown:")
        print(summary_df[['Section', 'S_Total', 'S_v_contrib', 'S_a_contrib', 
                         'S_cp_contrib', 'S_sp_contrib', 'S_temp_contrib', 'RiskClass']].to_string(index=False))

if __name__ == "__main__":
    main()
